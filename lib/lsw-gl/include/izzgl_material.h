//
// Created by jlemein on 22-02-21.
//
#pragma once

#include <GL/glew.h>
#include <fmt/format.h>
#include <gl_renderable.h>
#include <izz.h>
#include <izzgl_texture.h>
#include <spdlog/spdlog.h>
#include <filesystem>
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <memory>
#include <string>
#include <variant>
#include "geo_materialdescription.h"

namespace izz {
namespace gl {

enum class UType : uint32_t { FLOAT, FLOAT2, FLOAT3, FLOAT4, FLOAT_ARRAY, BOOL, INT, INT2, INT3, INT4, INT_ARRAY, MAT2, MAT3, MAT4 };

class UniformProperty {
 public:
  UniformProperty(GLint location = 0, void* data = nullptr, int length = 1)
    : m_location{location}
    , m_data{data}
    , m_length{length} {}

  GLint m_location;  /// @brief the location of the uniform parameter in the GLSL shader.
                     //  UType type;      /// @brief Type of the uniform property stored. @see UType.
  void* m_data;      /// @brief Offset in the UnscopedUniforms::pData attribute where the value is stored. Offset is expressed in bytes (uint8_t).
  int m_length;      /// @brief length of the property. This is expressed in number of elements (i.e. the length of the array irrespective of data type)
};

struct UnscopedUniforms {
  //  std::unique_ptr<Renderable_UnscopedUniform[]> pProperties;
  UniformProperty* pProperties;
  int numProperties;
  uint8_t* data;
  std::size_t sizeData;

  static inline UnscopedUniforms Allocate(int numProperties, std::size_t sizeOfData) {
    return UnscopedUniforms{new UniformProperty[numProperties], numProperties, new uint8_t[sizeOfData], sizeOfData};
  }

  static inline void DeallocateUnscopedUniforms(UnscopedUniforms* unscopedUniforms) {
    delete[] unscopedUniforms->pProperties;
    delete[] unscopedUniforms->data;
  }
};

/**
 * @brief Describes a uniform buffer object in OpenGL. Uniform buffer objects are used for named uniform blocks.
 */
struct UniformBuffer {
  GLuint bufferId{0};  // generated by glGenBuffers(1, &id).
  int blockIndex{-1};
  int blockBind{0};
  size_t size{0U};
  void* data{nullptr};
};

/**
 * A mapping of data location and size to keep the uniform blocks registered.
 */
struct UniformBlockInfo {
  std::string name;
  void* data;
  std::size_t size;
};

struct LightingInfo {
  // name of UBO struct in shader
  std::string ubo_struct_name;
};

struct UserProperties {
  // not sure if this is correct. ubo_name is overwritten for every new UBO
  std::string ubo_name;  // name of the uniform block in the shader, used by render engine to find ID.

  //  std::unordered_map<std::string, std::unique_ptr<UniformProperty>> uniforms;
  std::unordered_map<std::string, UniformProperty*> floatValues;
  std::unordered_map<std::string, UniformProperty*> intValues;
  std::unordered_map<std::string, UniformProperty*> floatArrayValues;
  std::unordered_map<std::string, UniformProperty*> booleanValues;
};

enum class ColorBuffer { UNUSED, CUBEMAP, BUFFER_1D, BUFFER_2D, TEXTURE_2D, TEXTURE_2D_MULTISAMPLE };

enum class FramebufferFormat { UNUSED, RGBA_FLOAT32, RGBA_UINT8 };
class FramebufferConfiguration {
 public:
  FramebufferFormat colorBuffers[4] = {FramebufferFormat::UNUSED, FramebufferFormat::UNUSED, FramebufferFormat::UNUSED, FramebufferFormat::UNUSED};
  FramebufferFormat depthBuffer;
  FramebufferFormat outColorBuffers[4] = {FramebufferFormat::UNUSED, FramebufferFormat::UNUSED, FramebufferFormat::UNUSED, FramebufferFormat::UNUSED};
};

struct TextureBuffer {
  GLuint textureId{0};  // as obtained via glGenTextures(, &id)
  GLint location{-1};   // as obtained via glGetUniformLocation
};

struct Material {
  // ==== PART OF MATERIAL DEFINITION ======================
  MaterialId id{-1};
  std::string name;

  //  MaterialProperty& operator[](const std::string& name) {
  //    return textures[name];
  //  }

  void useTextures() const {
    int tid = 0;
    for (auto& [name, texture] : textures) {
      //    for (int t = 0; t < textures.size(); ++t) {
      //      const auto& [name, texture] = textures[t];

      std::cout << "Activating texture " << name << " " << tid << std::endl;
      auto l = glGetUniformLocation(programId, name.c_str());
      std::cout << name << ": location " << texture.location << ", but found: " << l << std::endl;

      glActiveTexture(GL_TEXTURE0 + tid);
      glBindTexture(GL_TEXTURE_2D, texture.textureId);
      glUniform1i(texture.location, tid);
      ++tid;
    }
  }

  void pushUnscopedUniforms() const {
    for (const auto& value : unscopedUniforms.booleanValues) {
      glUniform1i(value.second->m_location, *reinterpret_cast<GLint*>(value.second->m_data));
    }

    for (const auto& value : unscopedUniforms.intValues) {
      glUniform1i(value.second->m_location, *reinterpret_cast<int*>(value.second->m_data));
    }

    for (const auto& value : unscopedUniforms.floatValues) {
      glUniform1f(value.second->m_location, *reinterpret_cast<GLfloat*>(value.second->m_data));
    }

    for (const auto& value : unscopedUniforms.floatArrayValues) {
      glUniform1fv(value.second->m_location, value.second->m_length, reinterpret_cast<GLfloat*>(value.second->m_data));
    }
  }

  void pushUniforms() const {
    for (const auto& uniform : uniformBuffers) {
      const auto& mapping = uniform.second;
      glBindBuffer(GL_UNIFORM_BUFFER, uniform.second.bufferId);
      glBindBufferBase(GL_UNIFORM_BUFFER, mapping.blockBind, mapping.bufferId);

      // is this needed?
      glUniformBlockBinding(programId, mapping.blockIndex, mapping.blockBind);

      spdlog::debug("Material {}: push uniforms", id);
      void* buff_ptr = glMapBuffer(GL_UNIFORM_BUFFER, GL_WRITE_ONLY);
      std::memcpy(buff_ptr, mapping.data, mapping.size);
      glUnmapBuffer(GL_UNIFORM_BUFFER);
    }

    pushUnscopedUniforms();
  }

  void setTexture(const std::string& name, Texture* pTexture) {
    if (!textures.contains(name)) {
      auto location = glGetUniformLocation(programId, name.c_str());
      if (location == GL_INVALID_INDEX) {
        spdlog::warn("Material: texture sampler '{}' could not be found in material {}: {}", name, programId, name);
      }
      textures[name] = TextureBuffer{pTexture != nullptr ? pTexture->bufferId : 0, location};
    } else {
      textures.at(name).textureId = pTexture->bufferId;
    }
  }

  GLint getTextureBuffer(const std::string& key) const {
    if (textures.count(key) > 0) {
      return textures.at(key).textureId;
    } else {
      return -1;
      //      throw std::runtime_error(fmt::format("Property {} (texture) does not exist for material {}", key, name));
    }
  }

  /// @brief Specifies input and output buffers for the shader.
  /// Materials can be chained to create multi-pass effects.
  FramebufferConfiguration framebufferConfiguration;

  /// Framebuffer object id
  //  unsigned int fbo {0U};

  /// Indicates whether the vertex and fragment shader files are in binary format (e.g. pre-compiled SPIRV format).
  //  bool isBinaryShader{false};
  //
  //  std::string vertexShader{""};
  //  std::string geometryShader{""};
  //  std::string fragmentShader{""};

  LightingInfo lighting;

  std::string shaderLayout{""};

  // special set of attributes
  glm::vec3 diffuse;
  glm::vec3 emissive;
  glm::vec3 ambient;
  glm::vec3 specular;
  glm::vec3 transparent;

  bool hasDiffuse{false};
  bool hasEmissive{false};
  bool hasSpecular{false};
  bool hasTransparent{false};
  bool hasAmbient{false};

  /// @brief predefined textures that gets mapped to from existing scene files.
  izz::TextureId diffuseTexture{-1};
  izz::TextureId specularTexture{-1};
  izz::TextureId normalTexture{-1};
  izz::TextureId roughnessTexture{-1};
  izz::TextureId opacityTexture{-1};

  UnscopedUniforms unscopedUniformBuffer;                           /// @brief GPU representation
  UserProperties unscopedUniforms;                                  /// @brief uniforms as part of a interface block (i.e. named uniform buffer object).
  std::unordered_map<std::string, UniformProperty*> m_allUniforms;  // Refers to all the uniform properties (unscoped and scoped).

  // contains map from name to property type
  std::unordered_map<std::string, izz::geo::PropertyType> propertyTypes;

  std::filesystem::path diffuseTexturePath{""};
  std::filesystem::path specularTexturePath{""};
  std::filesystem::path normalTexturePath{""};
  std::filesystem::path roughnessTexturePath{""};

  // TODO: move in separate class or struct.
  /**
   * @brief a texture maps from a parameter name (e.g. my_diffuse_tex) to a file path.
   * When programmatically assigned a texture to an entity, set the texturePath instead of loading the texture in textures.
   */
  //  std::unordered_map<std::string, std::string> texturePaths{};
  //  std::unordered_map<std::string, std::string> defaultTexturePaths{};
  /**
   * @brief mapping from parameter name to the texture resource.
   * This variable is for bookkeeping purposes only. Never set this attribute directly, your texture will not be loaded.
   * Use @see texturePaths instead.
   */

  // ==== PROPERTIES PART OF DEFINITION =======

  // ==== PROPERTIES BELOW ARE PART OF GPU ================================
  int programId{0};  /// @brief Program id as obtained via glCreateProgram()
  std::unordered_map<std::string, izz::gl::TextureBuffer> textures{};
  std::unordered_map<std::string, UniformBuffer> uniformBuffers{};
  //  std::vector<UniformBufferMapping> uniformBlocks;

  void setDiffuseMap(const std::string& path) {
    diffuseTexturePath = path;
  }

  void setNormalMap(const std::string& path) {
    normalTexturePath = path;
  }

  void setRoughnessMap(const std::string& path) {
    roughnessTexturePath = path;
  }

  void setSpecularMap(const std::string& path) {
    specularTexturePath = path;
  }

  // geo::ShadingMode shadingMode

  using UniformBlockRegistry = std::unordered_map<std::string, UniformBlockInfo>;

  //  UniformBlockRegistry uniformBlocks;

  template <typename T>
  void setProperty(const T& data) {
    setProperty(T::PARAM_NAME, data);
  }

  void setUniformFloat(std::string name, float value) {
    // dangerous cast here
    auto pValue = reinterpret_cast<GLfloat*>(m_allUniforms.at(name)->m_data);
    *pValue = value;
  }

  void setUniformVec4(std::string name, const glm::vec4& value) {
    // dangerous cast here
    memcpy(m_allUniforms.at(name)->m_data, glm::value_ptr(value), sizeof(GLfloat) * 4);
  }

  void setUniformInt(std::string name, int value) {
    // dangerous cast here
    auto pValue = reinterpret_cast<GLint*>(m_allUniforms.at(name)->m_data);
    *pValue = value;
  }

  void setUniformBool(std::string name, bool value) {
    // dangerous cast here
    auto pValue = reinterpret_cast<GLint*>(m_allUniforms.at(name)->m_data);
    *pValue = static_cast<GLint>(value);
  }

  void setUniformFloatArray(std::string name, const std::vector<float>& value) {
    // dangerous cast here
    memcpy(m_allUniforms.at(name)->m_data, value.data(), sizeof(GLfloat) * value.size());
  }

  glm::vec4& getUniformVec4(std::string name) const {
    return *reinterpret_cast<glm::vec4*>(m_allUniforms.at(name)->m_data);
  }

  float& getUniformFloat(std::string name) const {
    return *reinterpret_cast<float*>(m_allUniforms.at(name)->m_data);
  }

  std::vector<float> getUniformFloatArray(std::string name) const {
    auto prop = m_allUniforms.at(name);
    float* pStart = reinterpret_cast<float*>(prop->m_data);
    return std::vector<float>{pStart, pStart + prop->m_length};
  }

  // TODO: deprecated, remove it in favor of the register call below.
  template <typename T>
  [[deprecated("Use a uniform block manager instead")]] void setProperty(const char* name, const T& data) {
    if (uniformBuffers.count(name) > 0) {
      memcpy(uniformBuffers.at(name).data, &data, sizeof(T));

    } else {
      //      properties[name].data = std::unique_ptr<T>{new T,
      //      std::default_delete<T>()};
      uniformBuffers[name].data = new T();
      memcpy(uniformBuffers[name].data, &data, sizeof(T));
    }
    uniformBuffers.at(name).size = sizeof(T);
  }

  /**
   * @brief Assigns a uniform buffer object to a material. A material will imediately render using the new assigned uniform buffer object.
   * @param name The name of the UBO struct in the shader.
   * @param buffer The uniform buffer object. Uniform buffers can be created via @see MaterialSystem.
   */
  void setUniformBuffer(const char* name, UniformBuffer buffer) {
    if (uniformBuffers.count(name) > 0) {
      throw std::runtime_error("Cannot add a uniform block {} to material {} that already exists.");
    } else {
      spdlog::info("Material {}: registered UBO {}", id, name);
      uniformBuffers[name] = buffer;
    }
  }
  //
  //  void* getProperty(const char* name) {
  //    try {
  //      return uniformBlocks.at(name).data;
  //    } catch (std::out_of_range&) {
  //      throw std::runtime_error(fmt::format("Cannot find shader property {} in shader.", name));
  //    }
  //  }

  template <typename T>
  T* getProperty() {
    return reinterpret_cast<T*>(getProperty(T::PARAM_NAME));
  }
};

}  // namespace gl
}  // namespace izz
